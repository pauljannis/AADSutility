"""
Utility for generating plots from droplet data.
Takes droplet data file(s) as input, as generated by the AADS_detect script 
(two rows: 'size /t absorbance')

Plottypes:
        -v_hist: Voltage histogram, gateable
        -v_kde: Voltage KDE (multiple input accepted)
        -s_hist: Size histogram, gateable
        -s_kde: Size KDE (multiple input accepted)
        -scatter: Scatterplot

Author: Paul Zurek, pjz26@cam.ac.uk
v1.0: Very basic functionality from my visualize-SNG and -MLT with added argparse
v1.1: Converting to actual absorbance
23/10/2018
Tested with python 3.6
"""

import argparse
from matplotlib import pyplot as plt
import seaborn as sns
import numpy as np
from random import random

parser = argparse.ArgumentParser(description="""Droplet plotting tool.
                                 Author: Paul Zurek (pjz26@cam.ac.uk).
                                 Version 1.1 (23/10/2018)""")
parser.add_argument('plottype', help='Select plottypes', 
                    default=[], nargs='*',
                    choices=('v_hist', 's_hist', 'v_kde', 's_kde', 'scatter'))
parser.add_argument('-i', '--input', help='input file(s)',
                    required=True, nargs='*')
parser.add_argument('--gate', help='set x range',
                    nargs=2, type=float)
parser.add_argument('-c', '--convert', action='store_true',
                    help='Convert V to absorbance')
parser.add_argument('-o', '--output', help='save plots', action='store_true')
parser.add_argument('-v', '--version', action='version', version='1.1')

args = parser.parse_args()

plottype = args.plottype
inp = args.input
g = args.gate
gate = False
if g is not None: gate = True
out = args.output
convert = args.convert

names = [n[0:-4] for n in inp]

sns.set()
sns.set_style("ticks")
sns.set_context("talk")



#Some hardcoded values that you might need to change
CONVERT_FACTOR = 1.1054  #Conversion factor to convert detection voltage to absorbance: Determined via WST-1 calibration curve. Thus only applicable to WST-1 absorbance!



#Load files
xs = []
ys = []
for f in inp:
    x, y = np.loadtxt(f, unpack=True, skiprows=6)
    xs.append(x)
    ys.append(y)

if convert:
    baseline = []
    for filename in inp:
        with open(filename, "r") as f:
            for i, line in enumerate(f):
                if i == 3:
                    try:
                        baseline.append(float(line))
                        if not 0 < float(line) < 11:
                            raise Exception('baseline not in range')
                    except ValueError as error:
                        print('Could not extract baseline:')
                        print(error)
    print('Baseline value extracted')
    
    yabs = []
    for i in range(len(ys)):
        v_empty = baseline[i] * CONVERT_FACTOR
        conv = [np.log10(v_empty / volt) for volt in ys[i]]
        yabs.append(conv)
            
    

#Set plot aestetics
if convert:
    bw = 0.005 #KDE bandwidth and v_hist binwidth
    #bins = np.arange(-0.2,2,0.01)
    xlabel = 'Absorbance'
    y_plot = yabs
else:
    bw = 0.05 #KDE bandwidth and v_hist binwidth
    #bins = np.arange(0,10,0.05)
    xlabel = 'Detection signal [V]'
    y_plot = ys

#Hist aesthetics: Larger bins and linewidth 1 or small bins and no linewidth looks good

if 'v_hist' in plottype:
    plt.figure(figsize=(10,8))
    bins = np.arange(min(y_plot[0]), max(y_plot[0]), bw)
    plt.hist(y_plot[0], density=True, bins=bins, color='k', linewidth=0)
    plt.ylabel('Relatie frequency')
    plt.xlabel(xlabel)
    if gate: plt.xlim(g[0], g[1])
    if out: plt.savefig('vhist_'+names[0]+'.png', bbox_inches='tight', dpi=300)

if 'v_kde' in plottype:
    plt.figure(figsize=(10,8))
    for i in range(len(y_plot)):
        sns.kdeplot(y_plot[i], bw=bw, shade=True, **{"label":names[i]})
    plt.ylabel('Probability density')
    plt.xlabel(xlabel)    
    plt.legend()
    if out: plt.savefig('vkde_'+names[0]+'.png', bbox_inches='tight', dpi=300)

if 's_hist' in plottype:
    plt.figure(figsize=(10,8))
    plt.hist(xs[0], density=True, color='k')
    plt.ylabel('Relatie frequency')
    plt.xlabel('Size [ms]')
    if gate: plt.xlim(g[0], g[1])
    if out: plt.savefig('shist_'+names[0]+'.png', bbox_inches='tight', dpi=300)

if 's_kde' in plottype:
    plt.figure(figsize=(10,8))
    for i in range(len(xs)):
        sns.kdeplot(xs[i], bw=0.02, shade=True, **{"label":names[i]})
    plt.ylabel('Probability density')
    plt.xlabel('Size [ms]')    
    plt.legend()
    if out: plt.savefig('skde_'+names[0]+'.png', bbox_inches='tight', dpi=300)
    
if 'scatter' in plottype:
    var = 0.026313     
    for i in range(len(xs[0])):
        xs[0][i] = xs[0][i] + ((random()-0.5)*var)
    plt.figure(figsize=(10,8))
    plt.scatter(xs[0], y_plot[0], alpha=0.1)
    plt.ylabel(xlabel)
    plt.xlabel("Size [ms]")
    if out: plt.savefig('scatter_'+names[0]+'.png', bbox_inches='tight', dpi=300)

plt.show()

